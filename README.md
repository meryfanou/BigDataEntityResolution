# K23a_project1

ΜΙΧΑΛΗΣ ΒΟΥΡΤΖΟΥΜΗΣ 1115201700018

ΜΕΡΟΠΗ ΦΑΝΟΥ 1115201700176

Έχουν υλοποιηθεί όλες οι απαιτήσεις της εργασίας, όπως περιγράφονται στην εκφώνηση

Η εργασία διαθέτει Makefile κάνοντας εύκολη την εκτέλεση της.
Επιλογές make:

    - make all : Διαγράφει προηγούμενες εκδόσεις των αρχείων (clean) δημιουργεί τους απαραίτητους φακέλους (dirs) και εκτελέσιμα. Στη συνέχεια τρέχει τα tests (tests) και αν επιτύχουν τρέχει τη main με τα default ορίσματα (run), με τα αποτελέσματα της να αποθηκεύονται στο αρχείο matches_logDEF μέσα στο φάκελο Outputs.
    - make all ARGS="<arguments>": Κάνει ό,τι και η make all με τη διαφορά ότι τρέχει τη main με ορίσματα τα <arguments> που δίνει ο χρήστης
    - make valgrind: Τρέχει την main κάνοντας χρήση του valgrind.
    - make all_tests: Κάνει complie όλα τα tests σε ένα εκτελέσιμο.
    - make medium_labels: Τρέχει τη main κάνοντας χρήση του medium_labelled_dataset.
    - make run ARGS="<arguments>": Τρέχει τη main με ορίσματα τα <arguments> που δίνει ο χρήστης
    

myHash.c: 

          Υλοποιείται η δομη του HashTable και των συναρτήσεων της, όπως αυτές ορίζονται στο myHash.h.
          Συγκεκριμένα, το HashTable χρησιμοποιείται για την αποθήκευση των δομών mySpecs επιτυγχάνοντας. παραλλήλα, και την εύκολη και αποδοτική ανάκτιση τους (σε Ο(1) χρόνο).
          Για τη σωστή υλοποίηση του HashTable χρησιμοποιούνται οι δομές HashTable{}, bucket{} και record{}. Η δομη Hashtable κρατά έναν δέικτη στον πίνακα
          κατακερματισμού, το μεγεθός του, τις μέγιστες εγγραφές των bucket του και το πλήθος των εγγραφών του. Η δομή bucket περιέχει εναν δείκτη σε record, εναν μετρητή του πλήθους των εγγραφών της και εναν δείκτη σε μια επόμενη δομή bucket. Η κάθε δομή record αποτελέιται απο εναν δείτη προς μια δομή mySpec{} και εναν δείκτη σε επόμενη δομή record.
          Για την εισαγωγή ενος mySpec στον πίνακα κατακερματισμού χρησιμοποιείται ως "κλειδί" το specID του. 
          
          
myMatches.c:
           
           Υλοποιείται η δομή της "κλίκας", όπως περιγράφει η εκφώνηση και οι συναρτήσεις που την απαρτίζουν, όπως αυτές περιγράφονται στο myMatches.h.
           Κάθε δομή myMatches{} περιέχει εναν πίνακα τύπου ** mySpec{} που δύναται να αποθηκεύσει δείκτες προς τις αντίστοιχες δομές, καθώς και έναν μετρητή για το πλήθος των εγγραφών του πίνακα. Επιπλέον, καθώς κρίθηκε αναγκαίο όλες οι κλίκες να βρίσκονται μαζι σε μια λίστα, περιέχει έναν δείκτη προς μια επόμενη και έναν προς μια προηγούμενη δομη myMtaches, δημιουργόντας έτσι μια διπλά συνδεδεμένη λιστα.
           Η δομή matchesInfo κρατά την αρχή της λίστας αυτής καθώς και έναν μετρητή για τις εγγραφές της.
           
           
mySpec.c: 

          Στη δομή mySpec διατηρούνται το specID του προϊόντος, ένας πίνακας με τις ιδιότητές του (δομή specInfo: διατηρεί το όνομα της εκάστοτε ιδιότητας και μια λίστα με τις τιμές της) και η λίστα (ή κλίκα) με όλα τα specs με τα οποία ταιριάζει το συγκεκριμένο προϊόν (matches). Στην αρχή τα matches περιέχου μόνο
          το ίδιο το spec.


logistic.c:

          Πραγματοποιείται η υλοποίηση του λογιστικου μοντέλου παλινδρόμησης αλλά και της λίστας logistic_data_info, η οποία χρησιμοποιείται κατα την επιλογή της υλοποίησης με λιστες απο σπαρς.
          Για την υλοποίηση του μοντέλου χρησιμοποιούνται: η μέθοδος ανά ζεύγη από specs, εκπαίδευση ανά ένα ζεύγος και με batches, και ανάλογα με την επιλογή του χρήστη στα ορίσματα της main υλοποίηση των διανυσμάτων των κειμένων με λίστα από spars ή με vectors σε training και testing. Επιπλέον έχουν υλοποιηθεί και άλλοι τρόποι (υλοποιήση με spars σε training και testing / εκπαίδευση όλα μαζί) οι οποίοι κρίθηκαν λιγότερο αποτελεσματικοί και οι κλήσεις τους βρίσκονται σχολιασμέμες στη main.
          Η δομή του μοντέλου εκτός από έναν δείκτη προς την κλάση των βαρών του, κρατά και επιπλέον στατιστικά σχετικά με το συνολικό μέγεθος δεδομένων για τα οποία εκπαιδεύεται, το πλήθος των επαναλήψεων που κάνει train και το πλήθος των ξεχωριστών labels (0,1) ώστε να υλοποιηθεί η λειτουργία του "κινούμενου" threshold, βάσει της αναλογίας "0"/"1", με σκοπό της αύξηση της ακρίβειας του μοντέλου. Παρέχεται η επιπλέον δυνατότητα στον χρήστη να κάνει extract τα στοιχεία του μοντέλου σε ενα αρχείο στο φάκελο "Outputs".
          
threads.c:

          Γίνεται η υλοποίηση κάποιων βασικών συναρτήεων με σκοπό την ευκολότερη δημιουργία και διαχείρηση threads.

mbh.c:

          Περιέχει τις υλοποιήσεις των συναρτέων που απαρτίζουν μια δομή δεδομένων "min binary heap". Η υλοποίηση μια τέτοιας δομής κρίθηκε σκόπιμη για την επιλογή των Ν πιο σημαντικών λέξων από το BoWords, με σκοπό τη βελτίωση των χρόνων της εργασίας και την εύρυθμη λειτουργία του προγράμματος.


boWords.c:

          Πραγματοποιείται η υλοποίηση των δομών BoWrods και TF-IDF όπως αυτές ορίζονται στο boWords.h.
          Η δομή BoWords αποτελείται απο έναν πίνακα κατακερματισμού που δέχεται ως εγγραφές λέξεις.  Κάθε εγγραφή κρατά στοιχεία σχετικά με τα κέιμενα στα οποία έχει αναφερθεί και της τιμής tf-idf του. Η δομή BoWords διαθέτει τις κατάλληλες λειτουργίες ώστε να βρεθούν γηγορα και αποτελεσματικά οι σημαντικότερες εγγραφές του.
          Η δομή TF-IDF λειτρουργεί ως φίλτρο που εφαρμόζεται παω σε BoWords και υπολογίζει την τιμή τφ-δφ της κάθε εγγραφής του.


pretty_prints.c:

          Υλοποιείται μια δομή που καθορίζει τις εκτυπώσεις του προγράμματος.

tests/*test.c: 
          
          Τα αρχεία που βρίσκονται στο φέκλο "tests" και έχουν τη συγκεκριμένη κατάληξη, αποτελούν το σύνολο των unit tests για τις δομές που δημιουργήθηκαν.
          Η υλοποίηση τους γίνεται με τη βοήθεια της βιβλιοθήκης acutest.h
          Ολα τα tests μαζι, μέσω του make, γίνονται compile σε ενα εκτελέσιμο.

main.c:
          
          Η συνάρτηση main δέχεται τα εξής προαιρετικά ορίσματα:
          -ο filename, όπου filename το όνομα του αρχείου στο οποίο θα εκτυπωθούν τα αποτελέσματα. By default το filname που χρησιμοποιείται, σε περίπτωση που 
          εκτός απο το ορισμο -ο δεν δοθούν περαιτέρω ορίσματα, είναι το matches_log_DEF. Σε κάθε περίπτωση το αρχείο που δημιουργείται αποθυκεύεται στον φάκελο Outputs.
          -n filename, όπου filename το όνομα του αρχείου που θα περιέχει όλες τις αρνητικές συσχετίσεις που προκύπτουν απο το δίαβασμα του csv. Παρόμοι α λειτουργία με το "-o".
          -labels medium ή -l m, για την επιλογή του sigmod_medium_laballed_dataset.csv για το διάβασμα των ζευγαριών των specs. Αν δε δοθεί κάποιο όρισμα, by default
          χρησιμοποείται το αρχείο sigmod_large_laballed_dataset.csv.
          -labels <path_to_W> ή -l <path_to_W>, για την επιλογή δυναμικού μονοπατιού για το dataset W.
          -path <path_to_X> ή -p <path_to_X>, για την εισαγωγή του μονοπατιού για το dataset X με δυναμικό τρόπο.
          -m <choice> ή -model <choice>, επιλογή του επιθυμητού τρόπου εκπαίδευσης του μοντέλου. Συγκεκριμένα, για την επιλογή του spars θα πρέπει choice = s ενώ για την επιλογή του vector, choice = v
          -extract all_with_all ή -e all_with_all, για την επιλογή της εκτύπωσης των "ισχυρότερων" ζευγαριών από όλα τα δυνατά ζεύγη από όλα τα json αρχεία του datasetX


          Αφού διαβαστούν όσα ορίσματα υπάρχουν, δημιουργούνται και αρχικοποιούνται το hashTable και η λίστα με όλα τα matches (allMatches).
          Στη συνέχεια γίνεται η ανάγνωση των specs από το datasetX. Για κάθε spec-αρχείο ενός φακέλου του dataset, διαβάζονται και γίνονται parsed οι αντίστοιχες ιδιότητες, δημιουργείται η δομή για το spec και ενημερώνονται κατάλληλα οι δομές hashTable και allMatches.

          Για καλύτερη ακρίβεια στα αποτελέσματα του λογιστικού μοντέλου που θα δημιοργηθεί, πρώτα γίνεται shuffle των γραμμών του csv αρχείου, ώστε να υπάρχει κάποια τυχαιότητα στην κατανομή των θετικών και των αρνητικών ζευγαριών σε αυτό.
          Ακολουθεί το διάβασμα του 60% του csv αρχείου. Για κάθε ζεύγος από specs που ταιριάζουν μεταξύ τους, γίνεται η ανάκτησή τους μέσω του hashTable και ελέγχεται αν βρίσκονται ή όχι στην ίδια κλίκα. Στην περίπτωση που τα σπεκς δεν βρίσκονται ήδη στην ιδια κλίκα, γίνεται συγχώνευση των δυο κλικών. Στην αντίθετη περίπτωση ενημερώνονται κατάλληλα οι αρνητικές συσχετίσεις των αναφερώμενων κλικών.
          Παράλληλα, το προγραμμα κρατά στατιστικά για την επιτυχή εκπώνηση κάθε λειτουργίας του, κατά το δίβασμα του csv.
          Μόλις ολοκήρωθεί το μερικό διάβασμα του csv, δημιουργείται το train_set βάσει του οποίου θα πραγματοποιηθεί η εκπαίδευση του λογιστικού μοντέλου, και έπειτα ολοκηρώνεται η ανάγνωση του υπόλοιπου csv ώστε να δημιουργηθούν ανάλογα και τα train_set / val_set.

          Το πρόγραμμα, έπειτα, προχωρά στην υλοποίση του BoWords βάσει όλων των json αρχείων του datasetX. Αφού ολοκληρωθεί το bow αλλά και η εφαρμογή του tfidf γίνεται η επιλογή των Ν σημαντικότερων λέξεων του με τη χρήση του min binary heap (απο default επιλέγονται οι 1000).

          Έχοντας πλέον όλα τα sets αλλά και το λεξιλόγιο, γίνεται η εκπαίδευση και το testing του μοντέλου. Τα στοιχεία του εκπαιδευμένου μοντέλου αποθηκεύονται σε ενα αρχειο txt.

          Ακολουθεί η μέθοδος "όλα με όλα" κατα την οποία εξετάζονται όλοι οι δυνατοί συνδιασμοί ανάμεσα σε όλα τα json αρχεία και εκτυπώνονται τα πιο "δυνατά" ζευγάρια που εντοπίζονται, δηλαδή όσων η εκτίμηση είναι πάνω από το κατώφλι 0.01. Η διαδικασία αυτή είναι αρκετά αργή, γι' αυτό και δεν εκτελείται by default αλλά μόνο αν το επιλέξει ο χρήστης με το αντίστοιχο όρισμα.

          Στη συνέχεια, γίνεται η εκτύπωση όλών των θετικών και αρνητικών συσχετίσεων που έχουν προκύψει απο το δίαβασμα του csv στο stdout ή σε δύο αρχεία (ανάλογα με τις επιλογές στη main), καθώς και στατιστικών για το πόσα ζευγάρια υπάρχουν συνολικά αλλά και το πλήθος των κλικών.

          Στο τέλος του προγράμματος γίνεται, επιτυχημένα, η απελευθέρωση όλης της δυναμικά δεσμευμένης μνήμης που χρησιμοποιήθηκε. (Για το sigmod_large_labelled_dataset.csv εκτιμώμενος χρόνος εκτέλεσης με valgrind: 30 λεπτά)
          
          Ανά πάσα στιγμή και καθ' όσο τρέχει η main, υποστηρίζεται διαχείρηση λήψης ενός σήματος τερματισμού του εκτελέσιμου (SIGINT, SIGQUIT) οπότε διακόπτεται η όποια εργασία, αποδεσμεύεται η μνήμη και γίνεται ομαλός τερματισμός του προγράμματος με τα αντίστοιχα μηνύματα στο
          stdout.


